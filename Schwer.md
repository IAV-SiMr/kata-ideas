# Ideen für Coding Katas

## Schwer

1. **Kürzester Pfad in einem Graphen**
   - Die Funktion erhält einen gerichteten gewichteten Graphen, einen Startknoten und einen Zielknoten als Eingabe.
   - Die Funktion gibt den kürzesten Pfad vom Startknoten zum Zielknoten zurück.
   - Die Funktion verwendet den Dijkstra-Algorithmus zur Berechnung des kürzesten Pfads.
   - Die Funktion gibt `null` zurück, wenn kein Pfad vom Startknoten zum Zielknoten existiert.

2. **Longest Common Subsequence**
   - Die Funktion erhält zwei Strings als Eingabe.
   - Die Funktion gibt die längste gemeinsame Teilsequenz der beiden Strings zurück.
   - Die Funktion gibt eine leere Zeichenkette zurück, wenn keine gemeinsame Teilsequenz existiert.
   - Die Funktion muss eine effiziente dynamische Programmierungslösung implementieren.

3. **Sudoku-Solver**
   - Die Funktion erhält ein unvollständiges Sudoku-Rätsel als Eingabe.
   - Die Funktion gibt eine vollständig gelöste Version des Sudoku-Rätsels zurück.
   - Die Funktion muss eine effiziente Backtracking-Algorithmuslösung implementieren.
   - Die Funktion gibt `null` zurück, wenn das Sudoku-Rätsel keine gültige Lösung hat.

4. **Knapsack Problem**
   - Die Funktion erhält eine Liste von Gegenständen mit Gewichten und Werten sowie die maximale Kapazität eines Rucksacks als Eingabe.
   - Die Funktion gibt den maximalen Wert zurück, den der Rucksack tragen kann.
   - Die Funktion muss eine effiziente dynamische Programmierungslösung implementieren.
   - Die Funktion gibt 0 zurück, wenn die Eingabeliste leer ist oder die maximale Kapazität 0 beträgt.

5. **Längster Pfad in einem Graphen**
   - Die Funktion erhält einen gerichteten gewichteten Graphen, einen Startknoten und einen Zielknoten als Eingabe.
   - Die Funktion gibt den längsten Pfad vom Startknoten zum Zielknoten zurück.
   - Die Funktion verwendet den Bellman-Ford-Algorithmus zur Berechnung des längsten Pfads.
   - Die Funktion gibt `null` zurück, wenn kein Pfad vom Startknoten zum Zielknoten existiert.

6. **Minimum Spanning Tree**
   - Die Funktion erhält einen gewichteten Graphen als Eingabe.
   - Die Funktion gibt den minimalen Spannbaum des Graphen zurück.
   - Der minimale Spannbaum verbindet alle Knoten des Graphen mit minimalen Gesamtgewicht.
   - Die Funktion muss den Kruskal-Algorithmus oder den Prim-Algorithmus implementieren.

7. **Längster gemeinsamer Teilstring**
   - Die Funktion erhält zwei Strings als Eingabe.
   - Die Funktion gibt den längsten gemeinsamen Teilstring der beiden Strings zurück.
   - Die Funktion gibt eine leere Zeichenkette zurück, wenn kein gemeinsamer Teilstring existiert.
   - Die Funktion muss eine effiziente dynamische Programmierungslösung implementieren.

8. **Traveling Salesman Problem**
   - Die Funktion erhält einen vollständigen gewichteten Graphen als Eingabe.
   - Die Funktion gibt den kürzesten Rundreisepfad zurück, der alle Knoten des Graphen besucht.
   - Die Funktion muss eine effiziente dynamische Programmierungslösung implementieren.
   - Die Funktion gibt `null` zurück, wenn der Graph nicht vollständig ist.

9. **Kleinster gemeinsamer Teiler**
   - Die Funktion erhält eine Liste von Zahlen als Eingabe.
   - Die Funktion gibt den kleinsten gemeinsamen Teiler aller Zahlen in der Liste zurück.
   - Die Funktion muss eine effiziente mathematische Lösung implementieren.
   - Die Funktion gibt `null` zurück, wenn die Eingabeliste leer ist.

10. **Regulärer Ausdruck Matching**
    - Die Funktion erhält einen regulären Ausdruck und einen Eingabe-String als Eingabe.
    - Die Funktion gibt `true` zurück, wenn der reguläre Ausdruck mit dem Eingabe-String übereinstimmt.
    - Die Funktion gibt `false` zurück, wenn der reguläre Ausdruck nicht mit dem Eingabe-String übereinstimmt.
    - Die Funktion muss den Thompson-Algorithmus oder den NFA-DFA-Algorithmus zur Implementierung des regulären Ausdruck-Matchings verwenden.






















